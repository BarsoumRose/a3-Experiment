<script src="https://d3js.org/d3.v4.min.js"></script>


<style>
  .chosen-rect {
    fill: none;
  }
</style>

<body>
  <h1> Experiment </h1>
  <!--   
    Stacked Bar Chart
  -->
  <div class="chart"></div>

  <div>
    <form>
      <label for="fname">How many times bigger is the larger piece than the smaller piece. Answer 1 if they are the same
        size.
      </label>
      <input type="text" id="fname" name="firstname" placeholder="Your guess..">
      <input type="submit" value="Submit" class="submitBtn">
    </form>
  </div>

  <!--
    Regular Bar Chart
  -->

  <!--
    Pie Chart 
  -->

</body>

<script>

  function getRandomInt(max) {
    return Math.floor(Math.random() * max);
  }


  var stackedBarData = []
  let percentArr = []
  d3.csv("testData.csv", function (data) {
    for (let i = 0; i < data.length; i++) {
      if (data[i].chart == 2) {
        stackedBarData.push(data[i].value);
      }
    }

    const sampleData = [
      { label: 'Group-1', value: parseInt(stackedBarData[0]), chosen: false },
      { label: 'Group-2', value: parseInt(stackedBarData[1]), chosen: false },
      { label: 'Group-3', value: parseInt(stackedBarData[2]), chosen: false },
      { label: 'Group-4', value: parseInt(stackedBarData[3]), chosen: false },
      { label: 'Group-5', value: parseInt(stackedBarData[4]), chosen: false },
      { label: 'Group-6', value: parseInt(stackedBarData[5]), chosen: false },
      { label: 'Group-7', value: parseInt(stackedBarData[6]), chosen: false },
    ]

    let previous = -1
    for (let i = 0; i < 2; i++) {
      let tempNum = getRandomInt(7)
      while (tempNum == previous) {
        tempNum = getRandomInt(7)
      }
      sampleData[tempNum].chosen = true
      previous = tempNum;
    }

    // group data for chart and filter out zero values

    function groupData(data, total) {
      // use scale to get percent values
      const percent = d3.scaleLinear()
        .domain([0, total])
        .range([0, 100])
      // filter out data that has zero values
      // also get mapping for next placement
      // (save having to format data for d3 stack)
      let cumulative = 0
      const _data = data.map(d => {
        cumulative += d.value
        return {
          value: d.value,
          // want the cumulative to prior value (start of rect)
          cumulative: cumulative - d.value,
          label: d.label,
          percent: percent(d.value),
          chosen: d.chosen
        }
      }).filter(d => d.value > 0)
      return _data
    }

    function stackedBar(bind, data, config) {
      config = {
        f: d3.format('.1f'),
        margin: { top: 20, right: 10, bottom: 20, left: 10 },
        width: 800,
        height: 200,
        barHeight: 100,
        colors: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#1D412F', '#241D4D'],
        ...config
      }
      const { f, margin, width, height, barHeight, colors } = config
      const w = width - margin.left - margin.right
      const h = height - margin.top - margin.bottom
      const halfBarHeight = barHeight / 2

      const total = d3.sum(data, d => d.value)
      const _data = groupData(data, total)

      console.log(_data)

      // set up scales for horizontal placement
      const xScale = d3.scaleLinear()
        .domain([0, total])
        .range([0, w])

      // create svg in passed in div
      const selection = d3.select(bind)
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .append('g')
        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')', 'rotate(-10 50 100)')

      // stack rect for each data value
      selection.selectAll('rect')
        .data(_data)
        .enter().append('rect')
        .attr('class', 'rect-stacked')
        .attr('x', d => xScale(d.cumulative))
        .attr('y', h / 2 - halfBarHeight)
        .attr('height', barHeight)
        .attr('width', d => xScale(d.value))
        .style('fill', (d, i) => colors[i])
        .style('cursor', 'pointer')


      // add values on bar
      selection.selectAll('.text-value')
        .data(_data)
        .enter().append('text')
        .attr('class', 'text-value')
        .attr('text-anchor', 'middle')
        .attr('x', d => xScale(d.cumulative) + (xScale(d.value) / 2))
        .attr('y', (h / 2) + 5)
        .text(d => {
          if (d.chosen) {
            return "This One";
          } else {
            "";
          }
        })
        .style('display', 'none')

      // add some labels for percentages
      selection.selectAll('.text-percent')
        .data(_data)
        .enter().append('text')
        .attr('class', 'text-percent')
        .attr('text-anchor', 'middle')
        .attr('x', d => xScale(d.cumulative) + (xScale(d.value) / 2))
        .attr('y', (h / 2) - (halfBarHeight * 1.1))
        .text(d => f(d.percent) + ' %')
        .style('display', 'none')

      // add the labels
      selection.selectAll('.text-label')
        .data(_data)
        .enter().append('text')
        .attr('class', 'text-label')
        .attr('text-anchor', 'middle')
        .attr('x', d => xScale(d.cumulative) + (xScale(d.value) / 2))
        .attr('y', (h / 2) + (halfBarHeight * 1.1) + 20)
        .style('fill', (d, i) => colors[i])
        .text(d => {
          if (d.chosen) {
            return "This One";
          } else {
            "";
          }
        })

      d3.select('.submitBtn')
        .data(_data)
        .on('click', function (d) {
          let observedValue = 0
          if (!isNaN(parseInt(document.getElementById('fname').value))) {
            observedValue = (parseInt(document.getElementById('fname').value))
          } else {
            alert("Please Input Valid Number")
          }
          for (let i = 0; i < _data.length; i++) {
            if (_data[i].chosen) {
              percentArr.push(_data[i].percent)
            }
          }

          let trueValue = Math.max(...percentArr) / Math.min(...percentArr)
          alert(`The correct answer is ${trueValue}\n
                  The error rate is: ${Math.abs((trueValue - observedValue) / trueValue) * 100}%`)
          while (percentArr.length > 0) {
            percentArr.pop()
          }
        })
    }
    // render chart
    stackedBar('.chart', sampleData)
  });


  console.log(d3); // test if d3 is loaded
  // set the dimensions and margins of the graph
  var margin = { top: 5, right: 30, bottom: 45, left: 40 },
    width = 900 - margin.left - margin.right,
    height = 700 - margin.top - margin.bottom;

  // append the svg object to the body of the page
  var svg = d3.select("body")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform",
      "translate(" + margin.left + "," + margin.top + ")");

     //data



</script>